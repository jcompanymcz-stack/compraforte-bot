// index.js — ES Module (compatível com "type": "module")
import 'dotenv/config'
import makeWASocket, { useMultiFileAuthState, Browsers, fetchLatestBaileysVersion } from '@whiskeysockets/baileys'
import Pino from 'pino'
import * as qrcode from 'qrcode-terminal'

import { setupCore, onText } from './lib/core.js'
import { initAll } from './lib/db.js'

const AUTH_DIR = process.env.AUTH_DIR || './auth'
const normalize = (jid='') => jid.replace(/@s\.whatsapp\.net$/, '').replace(/[^0-9]/g, '')

async function start(){
  const tables = await initAll()
  await setupCore(tables)

  const { state, saveCreds } = await useMultiFileAuthState(AUTH_DIR)
  const { version } = await fetchLatestBaileysVersion()

  const sock = makeWASocket({
    version,
    auth: state,
    printQRInTerminal: true,
    browser: Browsers.macOS('Safari'),
    logger: Pino({ level: 'info' }),
    syncFullHistory: false
  })

  sock.ev.on('creds.update', saveCreds)

  sock.ev.on('connection.update', (u) => {
    const { connection, lastDisconnect, qr } = u

    if (qr) {
      try { qrcode.generate(qr, { small: true }) } catch {}
      console.log('👉 Escaneie neste link:')
      console.log(`https://api.qrserver.com/v1/create-qr-code/?size=320x320&data=${encodeURIComponent(qr)}`)
    }

    if (connection === 'open') {
      console.log('✅ Conectado ao WhatsApp com sucesso!')
    }

    if (connection === 'close') {
      const msg = (lastDisconnect?.error && (lastDisconnect.error.output?.statusCode || lastDisconnect.error.message)) || 'desconectado'
      console.log('🔌 Conexão fechada:', msg, ' → tentando reconectar em 3s...')
      setTimeout(() => start().catch(err => console.error('FALHA ao reconectar:', err)), 3000)
    }

    if (lastDisconnect?.error) {
      console.error('❌ Detalhes:', lastDisconnect.error?.message || lastDisconnect.error)
    }
  })

  sock.ev.on('messages.upsert', async ({ type, messages }) => {
    if (type !== 'notify') return
    for (const m of messages){
      try{
        if (!m.message || m.key.fromMe) continue
        const jid = m.key.remoteJid
        const from = normalize(jid)
        const text =
          m.message.conversation ||
          m.message.extendedTextMessage?.text ||
          m.message.imageMessage?.caption ||
          m.message.buttonsResponseMessage?.selectedDisplayText ||
          m.message.listResponseMessage?.singleSelectReply?.selectedRowId ||
          ''

        const clean = (text || '').trim()
        if (!clean) continue

        const send = async (t) => sock.sendMessage(jid, { text: t })
        await onText({ from, text: clean, send })
      }catch(e){
        console.error('Erro no processamento da mensagem:', e?.message || e)
      }
    }
  })
}

start().catch(err => console.error('FALHA geral:', err))
